--- NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv.c.orig	2004-03-08 15:48:46.000000000 +0100
+++ NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv.c	2004-03-08 15:55:11.718705016 +0100
@@ -2007,7 +2007,7 @@
  * waiting on the wait queue
  */
 
-void nv_set_hotkey_occurred_flag(void)
+void NV_API_CALL nv_set_hotkey_occurred_flag(void)
 {
     nv_printf(NV_DBG_EVENTINFO,"setting the hotkey occurred flag!\n");
 
@@ -2191,7 +2191,7 @@
  *** EXPORTS to rest of resman
  ***/
 
-void *nv_find_nv_mapping(
+void * NV_API_CALL nv_find_nv_mapping(
     nv_state_t    *nv,
     unsigned long  address
 )
@@ -2262,7 +2262,7 @@
  * the TYPE_AGP flag to differeniate it from a PCI allocation.
  * failure is fine, we may just be checking if a given page is agp
  */
-void *
+void * NV_API_CALL
 nv_find_agp_kernel_mapping(
     nv_state_t    *nv,
     unsigned long  address
@@ -2339,7 +2339,7 @@
     return (unsigned long) NULL;
 }
 
-unsigned long
+unsigned long NV_API_CALL
 nv_get_kern_phys_address(
     unsigned long address
 )
@@ -2369,7 +2369,7 @@
     return _get_phys_address(address, 1);
 }
 
-unsigned long
+unsigned long NV_API_CALL
 nv_get_user_phys_address(
     unsigned long address
 )
@@ -2392,7 +2392,7 @@
 
 
 /* allocate memory for DMA push buffers */
-int
+int NV_API_CALL
 nv_alloc_pages(
     nv_state_t *nv,
     void **pAddress,
@@ -2584,7 +2584,7 @@
         return -1; \
     }
 
-int
+int NV_API_CALL
 nv_free_pages(
     nv_state_t *nv,
     void **pAddress,
@@ -2687,7 +2687,7 @@
     nvl->rm_lock_count = 0;
 }
 
-void nv_lock_rm(
+void NV_API_CALL nv_lock_rm(
     nv_state_t *nv
 )
 {
@@ -2707,7 +2707,7 @@
    nvl->rm_lock_count = 1;
 }
 
-void nv_unlock_rm(
+void NV_API_CALL nv_unlock_rm(
     nv_state_t *nv
 )
 {
@@ -2721,7 +2721,7 @@
     spin_unlock_irq(&nvl->rm_lock);
 }
 
-void nv_lock_heap(
+void NV_API_CALL nv_lock_heap(
     nv_state_t *nv
 )
 {
@@ -2731,7 +2731,7 @@
     nv_lock(nvl->heap_lock);
 }
 
-void nv_unlock_heap(
+void NV_API_CALL nv_unlock_heap(
     nv_state_t *nv
 )
 {
@@ -2744,7 +2744,7 @@
 /*
 ** post the event
 */
-void nv_post_event(
+void NV_API_CALL nv_post_event(
     nv_state_t *nv,
     nv_event_t *event,
     U032        handle,
@@ -2782,7 +2782,7 @@
     nv_unlock_irq(nvfp->fp_lock, eflags);
 }
 
-int nv_get_event(
+int NV_API_CALL nv_get_event(
     nv_state_t *nv,
     VOID *void_file,
     nv_event_t *event,
@@ -2823,7 +2823,7 @@
 }
 
 
-int
+int NV_API_CALL
 nv_agp_init(
     nv_state_t *nv,
     VOID **phys_start,
@@ -2889,7 +2889,7 @@
     return status;
 }
 
-int
+int NV_API_CALL
 nv_agp_teardown(
     nv_state_t *nv
 )
@@ -2927,7 +2927,7 @@
  * (if the linear mapping was real, this is the page that would have been
  * addressed by the virtual address. I know, confusing).
  */
-int
+int NV_API_CALL
 nv_agp_translate_address(
     nv_state_t *nv,
     void       *base,
@@ -2957,7 +2957,7 @@
 }
 
 
-int
+int NV_API_CALL
 nv_int10h_call(
     nv_state_t *nv,
     U032 *eax,
@@ -2971,7 +2971,7 @@
 }
 
 /* set a timer to go off every second */
-int 
+int NV_API_CALL
 nv_start_rc_timer(
     nv_state_t *nv
 )
@@ -2992,7 +2992,7 @@
     return 0;
 }
 
-int 
+int NV_API_CALL
 nv_stop_rc_timer(
     nv_state_t *nv
 )
--- NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/os-interface.c.orig	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/os-interface.c	2004-03-08 16:10:44.435910448 +0100
@@ -35,7 +35,7 @@
 }
 #endif
 
-RM_STATUS os_raise_smp_barrier(VOID)
+RM_STATUS NV_API_CALL os_raise_smp_barrier(VOID)
 {
     os_block_on_smp_barrier = 1;
 #ifdef CONFIG_SMP
@@ -45,26 +45,26 @@
     return RM_OK;
 }
 
-RM_STATUS os_clear_smp_barrier(VOID)
+RM_STATUS NV_API_CALL os_clear_smp_barrier(VOID)
 {
     os_block_on_smp_barrier = 0;
     return RM_OK;
 }
 
 // return TRUE if the caller is the super-user
-BOOL os_is_administrator(
+BOOL NV_API_CALL os_is_administrator(
     PHWINFO pDev
 )
 {
     return NV_IS_SUSER();
 }
 
-U032 os_get_page_size(VOID)
+U032 NV_API_CALL os_get_page_size(VOID)
 {
     return PAGE_SIZE;
 }
 
-ULONG os_get_page_mask(VOID)
+ULONG NV_API_CALL os_get_page_mask(VOID)
 {
     return PAGE_MASK;
 }
@@ -78,7 +78,7 @@
 // just replace the code within osStringCopy with a call to the C library
 // function strcpy.
 //
-U008* os_string_copy(
+U008* NV_API_CALL os_string_copy(
     U008 *dst,
     const U008 *src
 )
@@ -86,7 +86,7 @@
     return strcpy(dst, src);
 }
 
-RM_STATUS os_strncpy_from_user(
+RM_STATUS NV_API_CALL os_strncpy_from_user(
     U008 *dst,
     const U008 *src,
     U032 n
@@ -99,7 +99,7 @@
 #endif
 }
 
-S032 os_string_compare(
+S032 NV_API_CALL os_string_compare(
     const U008 *s1,
     const U008 *s2
 )
@@ -107,14 +107,14 @@
     return strcmp(s1, s2);
 }
 
-U032 os_string_length(
+U032 NV_API_CALL os_string_length(
     const U008* str
 )
 {
     return strlen(str);
 }
 
-U008* os_mem_copy(
+U008* NV_API_CALL os_mem_copy(
     U008 *dst,
     const U008 *src,
     U032 length
@@ -123,7 +123,7 @@
     return memcpy(dst, src, length);
 }
 
-RM_STATUS os_memcpy_from_user(
+RM_STATUS NV_API_CALL os_memcpy_from_user(
     VOID *dst,
     const VOID* src,
     U032 length
@@ -132,7 +132,7 @@
     return copy_from_user(dst, src, length) ? RM_ERR_BAD_ADDRESS : RM_OK;
 }
 
-RM_STATUS os_memcpy_to_user(
+RM_STATUS NV_API_CALL os_memcpy_to_user(
     VOID *dst,
     const VOID* src,
     U032 length
@@ -141,7 +141,7 @@
     return copy_to_user(dst, src, length) ? RM_ERR_BAD_ADDRESS : RM_OK;
 }
 
-VOID* os_mem_set(
+VOID* NV_API_CALL os_mem_set(
     VOID* dst,
     U008 c,
     U032 length
@@ -150,7 +150,7 @@
     return memset(dst, (int)c, length);
 }
 
-S032 os_mem_cmp(
+S032 NV_API_CALL os_mem_cmp(
     const U008 *buf0,
     const U008* buf1,
     U032 length
@@ -159,7 +159,7 @@
     return memcmp(buf0, buf1, length);
 }
 
-VOID* os_copy_in_ioctl_param(
+VOID* NV_API_CALL os_copy_in_ioctl_param(
     VOID *dst,
     VOID *src,
     U032 length
@@ -172,7 +172,7 @@
     }
 }
 
-VOID* os_copy_out_ioctl_param(
+VOID* NV_API_CALL os_copy_out_ioctl_param(
     VOID *dst,
     VOID *src,
     U032 length
@@ -204,7 +204,7 @@
 
 #define KMALLOC_LIMIT 131072
 
-RM_STATUS os_alloc_mem(
+RM_STATUS NV_API_CALL os_alloc_mem(
     VOID **address,
     U032 size
 )
@@ -251,7 +251,7 @@
     return *address ? RM_OK : RM_ERR_NO_FREE_MEM;
 }
 
-void os_free_mem(VOID *address)
+void NV_API_CALL os_free_mem(VOID *address)
 {
     unsigned long va;
     int size;
@@ -273,7 +273,7 @@
  * we may allocate more pages than the caller really asked for.
  * we'll only lock down the number of pages the caller asked for.
  */
-RM_STATUS os_alloc_contig_pages(
+RM_STATUS NV_API_CALL os_alloc_contig_pages(
     VOID **address,
     U032 size
 )
@@ -310,7 +310,7 @@
  * the same number of pages we locked, and to calculate the order we
  * allocated, so we properly free the allocation.
  */
-VOID os_free_contig_pages(
+VOID NV_API_CALL os_free_contig_pages(
     VOID *address,
     U032 size
 )
@@ -335,7 +335,7 @@
 *
 *****************************************************************************/
 
-RM_STATUS os_get_current_time(
+RM_STATUS NV_API_CALL os_get_current_time(
     U032 *seconds,
     U032 *useconds
 )
@@ -371,7 +371,7 @@
  * this, we use mdelay() for any full millisecond to be safe.
  */
 
-RM_STATUS os_delay_us(U032 MicroSeconds)
+RM_STATUS NV_API_CALL os_delay_us(U032 MicroSeconds)
 {
     unsigned long mdelay_safe_msec;
     unsigned long usec;
@@ -411,7 +411,7 @@
  * remainder will be accounted for with mdelay().
  */
 
-RM_STATUS os_delay(U032 MilliSeconds)
+RM_STATUS NV_API_CALL os_delay(U032 MilliSeconds)
 {
     unsigned long MicroSeconds;
     unsigned long jiffies;
@@ -481,7 +481,7 @@
 }
 
 /* return CPU frequency in MHz */
-U032 os_get_cpu_frequency(VOID)
+U032 NV_API_CALL os_get_cpu_frequency(VOID)
 {
     u64 tsc[2];
     u32 tsc_d;
@@ -500,13 +500,13 @@
     return cpu_mhz;
 }
 
-RM_STATUS os_get_current_process(U032 *pPid)
+RM_STATUS NV_API_CALL os_get_current_process(U032 *pPid)
 {
     *pPid = current->pid;
     return RM_OK;
 }
 
-RM_STATUS os_kill_process(
+RM_STATUS NV_API_CALL os_kill_process(
     U032 pid,
     U032 sig
 )
@@ -531,7 +531,7 @@
 //
 // this is what actually outputs the data.
 //
-inline void out_string(const char *str)
+inline void NV_API_CALL out_string(const char *str)
 {
     printk("%d: %s", smp_processor_id(), str);
 }    
@@ -546,7 +546,7 @@
  * Returns the number of characters written.
  */
 
-int nv_printf(
+int NV_API_CALL nv_printf(
     int   debuglevel,
     const char *printf_format,
     ...
@@ -571,7 +571,7 @@
     return chars_written;
 }
 
-BOOL os_pci_device_present(
+BOOL NV_API_CALL os_pci_device_present(
     U016 vendor,
     U016 device
 )
@@ -587,7 +587,7 @@
         return ret; \
     }
 
-VOID* os_pci_init_handle(
+VOID* NV_API_CALL os_pci_init_handle(
     U008 bus,
     U008 slot,
     U008 function,
@@ -604,7 +604,7 @@
     return (VOID *) dev;
 }
 
-U008 os_pci_read_byte(
+U008 NV_API_CALL os_pci_read_byte(
     VOID *handle,
     U008 offset
 )
@@ -615,7 +615,7 @@
     return value;
 }
 
-U016 os_pci_read_word(
+U016 NV_API_CALL os_pci_read_word(
     VOID *handle,
     U008 offset
 )
@@ -626,7 +626,7 @@
     return value;
 }
 
-U032 os_pci_read_dword(
+U032 NV_API_CALL os_pci_read_dword(
     VOID *handle,
     U008 offset
 ) 
@@ -637,7 +637,7 @@
     return value;
 }
 
-VOID os_pci_write_byte(
+VOID NV_API_CALL os_pci_write_byte(
     VOID *handle,
     U008 offset,
     U008 value
@@ -647,7 +647,7 @@
     pci_write_config_byte( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_pci_write_word(
+VOID NV_API_CALL os_pci_write_word(
     VOID *handle,
     U008 offset,
     U016 value
@@ -657,7 +657,7 @@
     pci_write_config_word( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_pci_write_dword(
+VOID NV_API_CALL os_pci_write_dword(
     VOID *handle,
     U008 offset,
     U032 value
@@ -667,7 +667,7 @@
     pci_write_config_dword( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_io_write_byte(
+VOID NV_API_CALL os_io_write_byte(
     PHWINFO pdev,
     U032 address,
     U008 value
@@ -676,7 +676,7 @@
     outb(value, address);
 }
 
-VOID os_io_write_word(
+VOID NV_API_CALL os_io_write_word(
     PHWINFO pdev,
     U032 address,
     U016 value
@@ -685,7 +685,7 @@
     outw(value, address);
 }
 
-VOID os_io_write_dword(
+VOID NV_API_CALL os_io_write_dword(
     PHWINFO pdev,
     U032 address,
     U032 value
@@ -694,7 +694,7 @@
     outl(value, address);
 }
 
-U008 os_io_read_byte(
+U008 NV_API_CALL os_io_read_byte(
     PHWINFO pdev,
     U032 address
 )
@@ -702,7 +702,7 @@
     return inb(address);
 }
 
-U016 os_io_read_word(
+U016 NV_API_CALL os_io_read_word(
     PHWINFO pdev,
     U032 address
 )
@@ -710,7 +710,7 @@
     return inw(address);
 }
 
-U032 os_io_read_dword(
+U032 NV_API_CALL os_io_read_dword(
     PHWINFO pdev,
     U032 address
 )
@@ -718,14 +718,14 @@
     return inl(address);
 }
 
-ULONG os_cli(ULONG flags)
+ULONG NV_API_CALL os_cli(ULONG flags)
 {
     NV_SAVE_FLAGS(flags);
     NV_CLI();
     return flags;
 }
 
-ULONG os_sti(ULONG flags)
+ULONG NV_API_CALL os_sti(ULONG flags)
 {
     NV_RESTORE_FLAGS(flags);
     return flags;
@@ -789,7 +789,7 @@
  * achieve the same results on a PIII or higher
  */
 
-RM_STATUS os_set_mem_range(
+RM_STATUS NV_API_CALL os_set_mem_range(
     U032 start,
     U032 size,
     U032 mode
@@ -817,7 +817,7 @@
     return RM_ERROR;
 }
 
-RM_STATUS os_unset_mem_range(
+RM_STATUS NV_API_CALL os_unset_mem_range(
     U032 start,
     U032 size
 )
@@ -839,7 +839,7 @@
  * should this also check for Write-Combining??
  */
 
-VOID *os_map_kernel_space(
+VOID * NV_API_CALL os_map_kernel_space(
     U032 start,
     U032 size_bytes,
     U032 mode
@@ -864,7 +864,7 @@
     return vaddr;
 }
 
-VOID os_unmap_kernel_space(
+VOID NV_API_CALL os_unmap_kernel_space(
     VOID *addr,
     U032 size_bytes
 )
@@ -872,7 +872,7 @@
     NV_IOUNMAP(addr, size_bytes);
 }
 
-VOID* os_map_user_space(
+VOID* NV_API_CALL os_map_user_space(
     VOID *kaddr,
     VOID **priv,
     U032 size_bytes,
@@ -883,14 +883,14 @@
     return NULL;
 }
 
-VOID os_unmap_user_space(
+VOID NV_API_CALL os_unmap_user_space(
     VOID *uaddr,
     VOID *priv
 )
 {
 }
 
-VOID* os_map_io_space(
+VOID* NV_API_CALL os_map_io_space(
     U032 start,
     U032 size_bytes,
     VOID **priv,
@@ -920,7 +920,7 @@
     return (void *)(NV_UINTPTR_T) vma->vm_start;
 }
 
-VOID os_unmap_io_space(
+VOID NV_API_CALL os_unmap_io_space(
     VOID *addr,
     U032 size_bytes,
     VOID *priv,
@@ -937,7 +937,7 @@
 }
 
 // override initial debug level from registry
-VOID os_dbg_init(void)
+VOID NV_API_CALL os_dbg_init(void)
 {
     U032 new_debuglevel;
     if (RM_OK == rm_read_registry_dword(0,
@@ -950,7 +950,7 @@
     }
 }
 
-VOID os_dbg_set_level(U032 new_debuglevel)
+VOID NV_API_CALL os_dbg_set_level(U032 new_debuglevel)
 {
     nv_printf(NV_DBG_SETUP, "Changing debuglevel from 0x%x to 0x%x\n", cur_debuglevel, new_debuglevel);
     cur_debuglevel = new_debuglevel;
@@ -962,7 +962,7 @@
  * a lock or which threw the breakpoint. I should probably scan the list of
  * nv_state_t's and drop any held locks before throwing this breakpoint.
  */
-VOID os_dbg_breakpoint(void)
+VOID NV_API_CALL os_dbg_breakpoint(void)
 {
 #ifdef DEBUG
     out_string("Break\n");
